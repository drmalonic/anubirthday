<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Interactive Crossword Puzzle</title>
  <style>
    /* Basic page styling */
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    h1 {
      text-align: center;
    }
    /* Container for the crossword grid and hints */
    #crossword-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    /* The crossword grid (dynamically sized) */
    #grid-container {
      display: grid;
      gap: 1px;
      background-color: black;
    }
    .cell {
      position: relative;
      background-color: white;
      width: 40px;
      height: 40px;
    }
    /* Input elements to type letters */
    .cell input {
      width: 100%;
      height: 100%;
      border: none;
      text-align: center;
      font-size: 20px;
      text-transform: uppercase;
    }
    .cell input:focus {
      outline: 2px solid blue;
    }
    /* Black (blocked) cells */
    .black-cell {
      background-color: black;
    }
    /* Clue number in the top‐left corner */
    .number {
      position: absolute;
      top: 0;
      left: 0;
      font-size: 10px;
      margin: 1px;
    }
    /* Highlight “correct” cells */
    .correct {
      background-color: #a0e6a0;
    }
    /* Hints list styling */
    #hints-container {
      max-width: 300px;
    }
    #hints-container h3 {
      margin-bottom: 5px;
    }
    /* Virtual keyboard styling */
    #keyboard-container {
      text-align: center;
      margin-bottom: 20px;
    }
    #keyboard-container button {
      width: 30px;
      height: 30px;
      margin: 2px;
      font-size: 16px;
      text-transform: uppercase;
    }
    /* Submit button styling */
    #submit-button {
      display: block;
      margin: 0 auto;
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <h1>Interactive Crossword Puzzle</h1>
  <div id="crossword-container">
    <!-- The crossword grid will be generated here -->
    <div id="grid-container"></div>
    <!-- Hints displayed on the right -->
    <div id="hints-container">
      <h3>Across</h3>
      <ul id="across-hints"></ul>
      <h3>Down</h3>
      <ul id="down-hints"></ul>
    </div>
  </div>
  <!-- Virtual keyboard -->
  <div id="keyboard-container"></div>
  <!-- Submit button -->
  <button id="submit-button">Submit</button>
  
  <script>
    /***********************
     * CONFIGURATION DATA  *
     ***********************/
    
    /* 
      The provided clues list both the starting cell (row, col) and the answer.
      (Rows and columns are zero-indexed.)
      Note: Some answers (e.g. "BROOKSIDE" is 9 letters) require a grid larger than 7×7.
      In our implementation the grid dimensions are automatically set to fit all answers.
    */
    
    const acrossClues = [
      { number: 1, row: 0, col: 0, answer: "BROOKSIDE", hint: "Your favorite (sweet) snack once upon a time" },
      { number: 3, row: 2, col: 0, answer: "MISOSEXY", hint: "Our first ever date outside the US was at this restaurant" },
      { number: 5, row: 3, col: 4, answer: "HEART", hint: "Anu loves making ----- shaped pizzas" },
      { number: 6, row: 4, col: 0, answer: "JETSKI", hint: "What is our birthday ritual" },
      { number: 7, row: 5, col: 2, answer: "XMAS", hint: "What festival have we celebrated only once together" },
      { number: 8, row: 6, col: 0, answer: "BOBBOI", hint: "Keshu's favorite ice cream shop" },
      { number: 10, row: 5, col: 5, answer: "CLOTHES", hint: "Anu loves stealing my -----" }
    ];
    
    const downClues = [
      { number: 2, row: 1, col: 3, answer: "KESHU", hint: "You love calling me" },
      { number: 4, row: 0, col: 2, answer: "EDSHEERAN", hint: "Name of artist who has been our best concert we've been to" },
      { number: 9, row: 1, col: 1, answer: "GLIDERPORT", hint: "Location of date night 3 years ago" },
      { number: 11, row: 0, col: 6, answer: "CUDDLING", hint: "Our fav activity together" }
    ];
    
    // Black tiles as specified (these are the cells that must be “blocked”)
    const blackTiles = [
      { row: 2, col: 2 },
      { row: 4, col: 1 },
      { row: 6, col: 5 },
      { row: 6, col: 6 }
    ];
    
    
    /******************************************
     * DETERMINE THE GRID DIMENSIONS DYNAMICALLY
     ******************************************/
    
    // Compute the maximum row and column needed from all clues
    let maxRow = 0, maxCol = 0;
    
    function updateDimensions(clue, isAcross) {
      if (isAcross) {
        const lastCol = clue.col + clue.answer.length - 1;
        if (lastCol > maxCol) maxCol = lastCol;
        if (clue.row > maxRow) maxRow = clue.row;
      } else {
        const lastRow = clue.row + clue.answer.length - 1;
        if (lastRow > maxRow) maxRow = lastRow;
        if (clue.col > maxCol) maxCol = clue.col;
      }
    }
    
    acrossClues.forEach(clue => updateDimensions(clue, true));
    downClues.forEach(clue => updateDimensions(clue, false));
    
    // Grid dimensions (add one because rows and cols are zero-indexed)
    const gridRows = maxRow + 1;
    const gridCols = maxCol + 1;
    
    // Set the grid template columns accordingly
    const gridContainer = document.getElementById("grid-container");
    gridContainer.style.gridTemplateColumns = `repeat(${gridCols}, 40px)`;
    
    
    /*********************************
     * BUILD THE SOLUTION GRID ARRAY *
     *********************************/
    
    // Create a 2D array to store the correct letters (default: empty string)
    const solutionGrid = [];
    for (let r = 0; r < gridRows; r++) {
      solutionGrid[r] = [];
      for (let c = 0; c < gridCols; c++) {
        solutionGrid[r][c] = "";
      }
    }
    
    // Helper: Check if a given cell should be black.
    function isBlack(r, c) {
      return blackTiles.some(tile => tile.row === r && tile.col === c);
    }
    
    // Fill in the solution for across clues
    acrossClues.forEach(clue => {
      const letters = clue.answer.split("");
      for (let i = 0; i < letters.length; i++) {
        const c = clue.col + i;
        if (isBlack(clue.row, c)) {
          console.warn(`Conflict: Cell (${clue.row}, ${c}) is black for across clue ${clue.number}`);
          continue;
        }
        solutionGrid[clue.row][c] = letters[i];
      }
    });
    
    // Fill in the solution for down clues
    downClues.forEach(clue => {
      const letters = clue.answer.split("");
      for (let i = 0; i < letters.length; i++) {
        const r = clue.row + i;
        if (isBlack(r, clue.col)) {
          console.warn(`Conflict: Cell (${r}, ${clue.col}) is black for down clue ${clue.number}`);
          continue;
        }
        // If already filled, check for consistency
        if (solutionGrid[r][clue.col] && solutionGrid[r][clue.col] !== letters[i]) {
          console.warn(`Conflict at cell (${r}, ${clue.col}) for down clue ${clue.number}`);
        }
        solutionGrid[r][clue.col] = letters[i];
      }
    });
    
    
    /**********************************
     * GENERATE THE CROSSWORD GRID UI *
     **********************************/
    
    // We'll keep a 2D array of input element references to easily check user entries later.
    const cellInputs = [];
    // Also, record which cells should show a starting clue number.
    const startNumbers = {};
    [...acrossClues, ...downClues].forEach(clue => {
      const key = clue.row + "," + clue.col;
      // If two clues start in the same cell, use the smaller number.
      if (!startNumbers[key] || clue.number < startNumbers[key]) {
        startNumbers[key] = clue.number;
      }
    });
    
    // Create each cell in the grid.
    for (let r = 0; r < gridRows; r++) {
      cellInputs[r] = [];
      for (let c = 0; c < gridCols; c++) {
        const cellDiv = document.createElement("div");
        cellDiv.classList.add("cell");
        cellDiv.dataset.row = r;
        cellDiv.dataset.col = c;
        
        // If this cell is designated as black, mark it and do not add an input.
        if (isBlack(r, c)) {
          cellDiv.classList.add("black-cell");
          gridContainer.appendChild(cellDiv);
          cellInputs[r][c] = null;
          continue;
        }
        
        // Create an input element for white cells.
        const input = document.createElement("input");
        input.setAttribute("maxlength", "1");
        input.dataset.row = r;
        input.dataset.col = c;
        cellDiv.appendChild(input);
        
        // If this cell is the start of any clue, display the number.
        const key = r + "," + c;
        if (startNumbers[key]) {
          const numDiv = document.createElement("div");
          numDiv.classList.add("number");
          numDiv.textContent = startNumbers[key];
          cellDiv.appendChild(numDiv);
        }
        
        gridContainer.appendChild(cellDiv);
        cellInputs[r][c] = input;
      }
    }
    
    
    /******************************
     * VIRTUAL KEYBOARD FUNCTION  *
     ******************************/
    
    let activeCell = null;
    // When an input is focused, record it as the active cell.
    document.querySelectorAll(".cell input").forEach(input => {
      input.addEventListener("focus", function() {
        activeCell = this;
      });
    });
    
    // Create buttons A–Z.
    const keyboardContainer = document.getElementById("keyboard-container");
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for (let char of alphabet) {
      const btn = document.createElement("button");
      btn.textContent = char;
      btn.addEventListener("click", function() {
        if (activeCell) {
          activeCell.value = char;
        }
      });
      keyboardContainer.appendChild(btn);
    }
    
    
    /******************************
     * DISPLAY THE HINTS ON THE UI  *
     ******************************/
    
    // Populate the “Across” hints list.
    const acrossHintsList = document.getElementById("across-hints");
    acrossClues.forEach(clue => {
      const li = document.createElement("li");
      li.textContent = `${clue.number}A: ${clue.hint}`;
      acrossHintsList.appendChild(li);
    });
    
    // Populate the “Down” hints list.
    const downHintsList = document.getElementById("down-hints");
    downClues.forEach(clue => {
      const li = document.createElement("li");
      li.textContent = `${clue.number}D: ${clue.hint}`;
      downHintsList.appendChild(li);
    });
    
    
    /******************************
     * SUBMIT BUTTON & VALIDATION *
     ******************************/
    
    document.getElementById("submit-button").addEventListener("click", function() {
      // Check each across clue.
      acrossClues.forEach(clue => {
        let correct = true;
        for (let i = 0; i < clue.answer.length; i++) {
          const r = clue.row;
          const c = clue.col + i;
          if (isBlack(r, c)) {
            correct = false;
            break;
          }
          const input = cellInputs[r][c];
          if (!input || input.value.toUpperCase() !== clue.answer[i].toUpperCase()) {
            correct = false;
            break;
          }
        }
        // Highlight the cells if the answer is correct.
        for (let i = 0; i < clue.answer.length; i++) {
          const r = clue.row;
          const c = clue.col + i;
          const input = cellInputs[r][c];
          if (input) {
            if (correct) {
              input.classList.add("correct");
            } else {
              input.classList.remove("correct");
            }
          }
        }
      });
      
      // Check each down clue.
      downClues.forEach(clue => {
        let correct = true;
        for (let i = 0; i < clue.answer.length; i++) {
          const r = clue.row + i;
          const c = clue.col;
          if (isBlack(r, c)) {
            correct = false;
            break;
          }
          const input = cellInputs[r][c];
          if (!input || input.value.toUpperCase() !== clue.answer[i].toUpperCase()) {
            correct = false;
            break;
          }
        }
        // Highlight the cells if the answer is correct.
        for (let i = 0; i < clue.answer.length; i++) {
          const r = clue.row + i;
          const c = clue.col;
          const input = cellInputs[r][c];
          if (input) {
            if (correct) {
              input.classList.add("correct");
            } else {
              input.classList.remove("correct");
            }
          }
        }
      });
      
      // Optionally alert the user (or perform other actions) after checking.
      alert("Submission checked. Correct words are highlighted in green.");
    });
  </script>
</body>
</html>